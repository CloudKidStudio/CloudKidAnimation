<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/Animator.js - CloudKid Animation API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../cloudkid.png" title="CloudKid Animation API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/cloudkid.Animator.html">cloudkid.Animator</a></li>
            
                <li><a href="../classes/cloudkid.AnimatorTimeline.html">cloudkid.AnimatorTimeline</a></li>
            
                <li><a href="../classes/cloudkid.CharacterClip.html">cloudkid.CharacterClip</a></li>
            
                <li><a href="../classes/cloudkid.CharacterController.html">cloudkid.CharacterController</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/Animator.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function(undefined){
	
	// Imports
	var OS = cloudkid.OS,
		AnimatorTimeline = cloudkid.AnimatorTimeline,
		MovieClip = createjs.MovieClip;
	
	/**
	*   Animator is a static class designed to provided
	*   base animation functionality, using frame labels of MovieClips
	*
	*   @class cloudkid.Animator
	*   @static
	*   @author Matt Moore
	*/
	var Animator = function(){};
	
	/**
	* The current version of the Animator class 
	* 
	* @property {String} VERSION
	* @static
	*/
	Animator.VERSION = &quot;${version}&quot;;
	
	/**
	* If we fire debug statements 
	* 
	* @property {bool} debug
	*/
	Animator.debug = false;
	
	/**
	* The collection of timelines
	* 
	* @property {Array} _timelines
	* @private
	*/
	var _timelines = [];
	
	/**
	* A collection of timelines for removal - kept out here so it doesn&#x27;t need to be
	* reallocated every frame
	* 
	* @property {Array} _removedTimelines
	* @private
	*/
	var _removedTimelines = [];
	
	/** Look up a timeline by the instance
	* 
	* @property {Dictionary} _timelinesMap
	* @private
	*/
	var _timelinesMap = {};
	
	/**
	* If the Animator is paused
	* 
	* @property {bool} _paused
	* @private
	*/
	var _paused = false;
	
	/**
	* if the animator should use magic frame dropping technology
	* 
	* @property {bool} useFrameDropping
	* @static
	*/
	Animator.useFrameDropping = false;
	
	/**
	*	Sets the variables of the Animator to their defaults. Used when __timelines is null,
	*	if the Animator data was cleaned up but was needed again later.
	*	
	*	@function init
	*	@static
	*/
	Animator.init = function()
	{
		_timelines = [];
		_removedTimelines = [];
		_timelinesMap = {};
		_paused = false;
		Animator.useFrameDropping = false;
	};
	
	/**
	*	Stops all animations and cleans up the variables used.
	*	
	*	@function destroy
	*	@static
	*/
	Animator.destroy = function()
	{
		Animator.stopAll();
		
		_timelines = null;
		_removedTimelines = null;
		_timelinesMap = null;
	};
	
	/**
	*   Play an animation for a frame label event
	*   
	*   @function play
	*   @param {cloudkid.AnimatorTimeline} instance The timeline to animate
	*   @param {String} event The frame label event (e.g. &quot;onClose&quot; to &quot;onClose stop&quot;)
	*   @param {function} onComplete The function to callback when we&#x27;re done
	*   @param {function} onCompleteParams Parameters to pass to onComplete function
	*   @param {bool} dropFrames If Animator should check this for frame dropping, if frame dropping is allowed
	*   @param {int} frameOffset The number of frames into the animation to start
	*   @param {bool} doCancelledCallback Should an overridden animation&#x27;s callback function still run?
	*   @return {cloudkid.AnimatorTimeline} The Timeline object
	*   @static
	*/
	Animator.play = function(instance, event, onComplete, onCompleteParams, dropFrames, frameOffset, doCancelledCallback)
	{
		onComplete = onComplete || null;
		onCompleteParams = onCompleteParams || null;
		dropFrames = dropFrames || true;
		frameOffset = frameOffset || 0;
		doCancelledCallback = doCancelledCallback || false;
		
		if (!_timelines) 
			Animator.init();
		
		if (_timelinesMap[instance.id] !== undefined)
		{
			Animator.stop(instance, doCancelledCallback);
		}
				
		var timeline = Animator._makeTimeline(instance, event, onComplete, onCompleteParams, dropFrames);
		
		if (timeline.firstFrame &gt; -1 &amp;&amp; timeline.lastFrame &gt; -1)//if the animation is present and complete
		{
			timeline.realStartFrame = timeline.firstFrame + frameOffset;
			
			instance.gotoAndPlay(timeline.realStartFrame);
			
			// Before we add the timeline, we should check to see
			// if there are no timelines, then start the enter frame
			// updating
			if (!Animator._hasTimelines()) Animator._startUpdate();
			
			_timelines.push(timeline);
			_timelinesMap[instance.id] = timeline;
			
			return timeline;
		}
		
		if (DEBUG)
		{
			Debug.log(&quot;No event &quot; + event + &quot; was found, or it lacks an end, on this MovieClip &quot; + instance);
		}
		
		if (onComplete)
		{
			onComplete.apply(null, onCompleteParams);
		}
		return null;
		
	};
	
	/**
	*   Play an animation for a frame label event, starting at a random frame within the animation
	*   
	*   @function playAtRandomFrame
	*   @param {cloudkid.AnimatorTimeline} instance The timeline to animate
	*   @param {String} event The frame label event (e.g. &quot;onClose&quot; to &quot;onClose_stop&quot;)
	*   @param {function} onComplete The function to callback when we&#x27;re done
	*   @param {function} onCompleteParams Parameters to pass to onComplete function
	*   @param {bool} dropFrames If Animator should check this for frame dropping, if frame dropping is allowed
	*   @return {cloudkid.AnimatorTimeline} The Timeline object
	*   @static
	*/
	Animator.playAtRandomFrame = function(instance, event, onComplete, onCompleteParams, dropFrames)
	{
		onComplete = onComplete || null;
		onCompleteParams = onCompleteParams || null;
		dropFrames = dropFrames || true;
				
		if (!_timelines) 
			Animator.init();
		
		if (_timelinesMap[instance.id] !== undefined)
		{
			Animator.stop(instance, false);
		}
		
		var timeline = Animator._makeTimeline(instance, event, onComplete, onCompleteParams, dropFrames);
		
		if (timeline.firstFrame &gt; 0 &amp;&amp; timeline.lastFrame &gt; 0)//if the animation is present and complete
		{
			timeline.realStartFrame = Math.random() * (timeline.lastFrame - timeline.firstFrame) + timeline.firstFrame;
			
			instance.gotoAndPlay(timeline.realStartFrame);
			
			// Before we add the timeline, we should check to see
			// if there are no timelines, then start the enter frame
			// updating
			if (!Animator._hasTimelines()) Animator._startUpdate();
			
			_timelines.push(timeline);
			_timelinesMap[instance.id] = timeline;
			
			return timeline;
		}
		
		if (Animator.debug)
		{
			Debug.log(&quot;No event &quot; + event + &quot; was found, or it lacks an end, on this MovieClip &quot; + instance);
		}
		
		if (onComplete)
		{
			onComplete.apply(null, onCompleteParams);
		}
		return null;
	};
	
	/**
	*   Creates the AnimatorTimeline for a given animation
	*   
	*   @function _makeTimeline
	*   @param {cloudkid.AnimatorTimeline} instance The timeline to animate
	*   @param {String} event The frame label event (e.g. &quot;onClose&quot; to &quot;onClose stop&quot;)
	*   @param {function} onComplete The function to callback when we&#x27;re done
	*   @param {function} onCompleteParams Parameters to pass to onComplete function
	*   @param {bool} dropFrames If Animator should check this for frame dropping, if frame dropping is allowed
	*   @return {cloudkid.AnimatorTimeline} The Timeline object
	*   @private
	*   @static
	*/
	Animator._makeTimeline = function(instance, event, onComplete, onCompleteParams, dropFrames)
	{
		var timeline = new AnimatorTimeline();
		if(instance instanceof MovieClip === false)//not a movieclip
		{
			return timeline;
		}
		timeline.instance = instance;
		timeline.event = event;
		timeline.onComplete = onComplete;
		timeline.onCompleteParams = onCompleteParams;
		timeline.dropFrames = dropFrames;
				
		var startTime = instance.timeline.resolve(event); 
		var stopTime = instance.timeline.resolve(event + &quot;_stop&quot;);
		var stopLoopTime = instance.timeline.resolve(event + &quot;_loop&quot;);

		if (startTime !== undefined)
		{
			timeline.firstFrame = timeline.realStartFrame = startTime;
		}
		if (stopTime !== undefined)
		{
			timeline.lastFrame = stopTime;
		}
		else if (stopLoopTime !== undefined)
		{
			timeline.lastFrame = stopLoopTime;
			timeline.isLooping = true;
		}
		timeline.length = timeline.lastFrame - timeline.firstFrame;
		
		return timeline;
	};
	
	/**
	*   Stop the animation.
	*   
	*   @function stop
	*   @param {createjs.MovieClip} instance The MovieClip to stop the action on
	*   @param {bool} doOnComplete If we are suppose to do the complete callback when stopping (default is false)
	*   @static
	*/
	Animator.stop = function(instance, doOnComplete)
	{
		doOnComplete = doOnComplete || false;
		
		if (!_timelines) return;
		
		if (_timelinesMap[instance.id] === undefined)
		{
			if (DEBUG)
			{
				Debug.log(&quot;No timeline was found matching the instance id &quot; + instance);
			}
			return;
		}
		
		var timeline = _timelinesMap[instance.id];
		Animator._remove(timeline, doOnComplete);
	};
	
	/**
	*   Stop all current Animator animations.
	*   This is good for cleaning up all animation, as it doesn&#x27;t do a callback on any of them.
	*   
	*   @function stopAll
	*   @param {createjs.Container} container Optional - specify a container to stop timelines contained within
	*   @static
	*/
	Animator.stopAll = function(container)
	{
		if (!Animator._hasTimelines()) return;
		
		var timeline;
		var removedTimelines = _timelines.slice();

		for(var i=0; i &lt; removedTimelines.length; i++)
		{
			timeline = removedTimelines[i];
			
			if (!container || container.contains(timeline.instance))
			{
				Animator._remove(timeline, false);
			}
		}
	};
	
	/**
	*   Remove a timeline from the stack
	*   
	*   @function _remove
	*   @param {cloudkid.AnimatorTimeline} timeline
	*   @param {bool} doOnComplete If we do the on complete callback
	*   @private
	*   @static
	*/
	Animator._remove = function(timeline, doOnComplete)
	{
		var index = _removedTimelines.indexOf(timeline);
		if (index &gt;= 0)
		{
			_removedTimelines.splice(index, 1);
		}
		
		index = _timelines.indexOf(timeline);
		
		// We can&#x27;t remove an animation twice
		if (index &lt; 0) return;
		
		var onComplete = timeline.onComplete;
		var onCompleteParams = timeline.onCompleteParams;
		
		// Stop the animation
		timeline.instance.stop();
		
		// Remove from the stack
		_timelines.splice(index, 1);
		delete _timelinesMap[timeline.instance.id];
		
		// Clear the timeline
		timeline.instance = null;
		timeline.event = null;
		timeline.onComplete = null;
		timeline.onCompleteParams = null;
		
		// Check if we should stop the update
		if (!Animator._hasTimelines()) Animator._stopUpdate();
		
		if (doOnComplete &amp;&amp; onComplete)
		{
			onComplete.apply(null, onCompleteParams);
		}
	};
	
	/**
	*   Pause all tweens which have been excuted by Animator.play()
	*   
	*   @function pause
	*   @static
	*/
	Animator.pause = function()
	{
		if (!_timelines) return;
		
		if (_paused) return;
		
		_paused = true;
		
		for(var i = 0; i &lt; _timelines.length; i++)
		{
			_timelines[i].setPaused(true);
		}
		Animator._stopUpdate();
	};
	
	/**
	*   Resumes all tweens executed by the Animator.play()
	*   
	*   @function resume
	*   @static
	*/
	Animator.resume = function()
	{
		if(!_timelines) return;
		
		if (!_paused) return;
		
		_paused = false;
		
		// Resume playing of all the instances
		for(var i = 0; i &lt; _timelines.length; i++)
		{
			_timelines[i].setPaused(false);
		}
		if (Animator._hasTimelines()) Animator._startUpdate();
	};
	
	/**
	*   Pauses or unpauses all timelines that are children of the specified DisplayObjectContainer.
	*   
	*   @function pauseInGroup
	*   @param {bool} paused If this should be paused or unpaused
	*   @param {createjs.Container} container The container to stop timelines contained within
	*   @static
	*/
	Animator.pauseInGroup = function(paused, container)
	{
		if (!Animator._hasTimelines() || !container) return;
		
		for(var i=0; i&lt; _timelines.length; i++)
		{
			if (container.contains(_timelines[i].instance))
			{
				_timelines[i].setPaused(paused);
			}
		}
	};
	
	
	/**
	*   Get the timeline object for an instance
	*   
	*   @function getTimeline
	*   @param {createjs.MovieClip} instance MovieClip 
	*   @return {cloudkid.AnimatorTimeline} The timeline
	*   @static
	*/
	Animator.getTimeline = function(instance)
	{
		if (!Animator._hasTimelines()) return null;
		
		if (_timelinesMap[instance.id] !== undefined)
		{
			return _timelinesMap[instance.id];
		}
		return null;
	};
	
	/**
	*  Whether the Animator class is currently paused.
	*  
	*  @function getPaused
	*  @return {bool} if we&#x27;re paused or not
	*/
	Animator.getPaused = function()
	{
		return _paused;
	};
	
	/**
	*  Start the updating 
	*  
	*  @function _startUpdate
	*  @private
	*  @static
	*/
	Animator._startUpdate = function()
	{
		if (OS.instance)
			OS.instance.addUpdateCallback(&quot;Animator&quot;, Animator._update);
	};
	
	/**
	*   Stop the updating
	*   
	*   @function _stopUpdate
	*   @private
	*   @static
	*/
	Animator._stopUpdate = function()
	{
		if (OS.instance)
			OS.instance.removeUpdateCallback(&quot;Animator&quot;);
	};
	
	/**
	*   The update every frame
	*   
	*   @function
	*   @param {int} elapsed The time in milliseconds since the last frame
	*   @private
	*   @static
	*/
	Animator._update = function(elapsed)
	{
		if(!_timelines) return;
		
		/** The expected frame that a movieclip should be on when dropping frames. */
		var expected = 0;//used when dropping frames
		/** The framerate / 1000, for calculations (0.030 for 30fps) */
		var frameRate = 0;
		/** The expected length of a frame in milliseconds, to weed out wierd frames that are too short */
		var expectedFrameLength = 0;
		
		if(Animator.useFrameDropping)
		{
			frameRate = OS.instance.fps;
			expectedFrameLength = 1000 / frameRate;
			frameRate *= 0.001;
		}
		
		var timeline;
		var instance;
		var currentFrame;
		
		for (var i = 0; i &lt; _timelines.length; i++)
		{
			timeline = _timelines[i];
			
			if(timeline.getPaused()) continue;
			
			instance = timeline.instance;
			currentFrame = instance.timeline.position || 0;
			
			if (currentFrame &gt;= timeline.lastFrame || currentFrame &lt; timeline.firstFrame || timeline.isLastFrame)
			{
				if(currentFrame == timeline.lastFrame &amp;&amp; !timeline.isLastFrame)
				{
					timeline.isLastFrame = true;
					if(Animator.useFrameDropping &amp;&amp; timeline.dropFrames)
					{
						if(elapsed &lt; expectedFrameLength)
							timeline.timePassed += expectedFrameLength;
						else
							timeline.timePassed += elapsed;
					}
					instance.stop();
					continue;
				}
				if(timeline.isLooping)
				{
					if(timeline.isLastFrame)
					{
						timeline.isLastFrame = false;
					}
					
					if(Animator.useFrameDropping &amp;&amp; timeline.dropFrames)
					{
						if(currentFrame == 1 &amp;&amp; timeline.firstFrame &gt; 1)
						{
							instance.gotoAndPlay(timeline.firstFrame);
							timeline.timePassed = 0;
						}
						else
						{
							if(elapsed &lt; expectedFrameLength)
								timeline.timePassed += expectedFrameLength;
							else
								timeline.timePassed += elapsed;
							
							expected = Math.round(timeline.timePassed * frameRate) + timeline.realStartFrame;
							expected -= timeline.firstFrame;
							expected = expected % timeline.length + timeline.firstFrame;
							timeline.timePassed = Math.round((expected - timeline.firstFrame) / frameRate);
							timeline.realStartFrame = timeline.firstFrame;
							instance.gotoAndPlay(expected);
						}
					}
					else
						instance.gotoAndPlay(timeline.firstFrame);
					
					if (DEBUG)
					{
						Debug.log(&quot;animation ended - &quot; + timeline.event);
					}
					if (timeline.onComplete)
					{
						timeline.onComplete.apply(null, timeline.onCompleteParams);
					}
				}
				else
				{
					instance.gotoAndStop(timeline.lastFrame);
					_removedTimelines.push(timeline);
				}
			}
			//try to drop frames to keep up, timewise - may look bad, but shouldn&#x27;t result in animations interfering with timing
			else if(Animator.useFrameDropping &amp;&amp; timeline.dropFrames)
			{
				if(elapsed &lt; expectedFrameLength)
					timeline.timePassed += expectedFrameLength;
				else
					timeline.timePassed += elapsed;
				expected = Math.round(timeline.timePassed * frameRate) + timeline.realStartFrame;
					
				//if we are behind
				if(currentFrame &lt; expected)
				{
					if(expected &gt;= timeline.lastFrame)
					{
						if(expected == timeline.lastFrame)
						{
							timeline.isLastFrame = true;
							instance.gotoAndStop(expected);
							continue;
						}
						if(timeline.isLooping)
						{
							expected -= timeline.firstFrame;
							expected = expected % timeline.length + timeline.firstFrame;
							instance.gotoAndPlay(expected);
							timeline.timePassed = Math.round((expected - timeline.firstFrame) / frameRate);
							timeline.realStartFrame = timeline.firstFrame;

							if (timeline.onComplete)
							{
								timeline.onComplete.apply(null, timeline.onCompleteParams);
							}
						}
						else
						{
							//make sure it is on the last frame before we stop it
							instance.gotoAndStop(timeline.lastFrame);
							_removedTimelines.push(timeline);
						}
					}
					else//otherwise, just skip ahead as needed
					{
						instance.gotoAndPlay(expected);
					}
				}
			}
		}
		for(i = 0; i &lt; _removedTimelines.length; i++)
		{
			timeline = _removedTimelines[i];
			Animator._remove(timeline, true);
		}
	};
	
	/**
	*  Check to see if we have timeline
	*  
	*  @function _hasTimelines
	*  @return {bool} if we have timelines
	*  @private
	*  @static
	*/
	Animator._hasTimelines = function()
	{
		if(!_timelines) return false;
		return _timelines.length &gt; 0;
	};
	
	/**
	*  String representation of this class
	*  
	*  @function toString
	*  @return String
	*  @static
	*/
	Animator.toString = function() 
	{
		return &quot;[Animator version:&quot; + Animator.VERSION + &quot;]&quot;;
	};
	
	// Assign to the global namespace
	namespace(&#x27;cloudkid&#x27;).Animator = Animator;

}());
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
